# -*- coding: utf-8 -*-
"""helper_functions

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lttgK729Hi3u8pbgJjzdpw2wqxTqNsXA

## Helper Functions

The core algorithms (LU factorization, forward/backward substitution, solver, and error metrics) are implemented in the file `helper_functions.py`, which is included below.
"""

import numpy as np

"""defining a function 'lu_factorization(A)' that Perform LU factorization with partial pivoting and returns P, L, U such that PA = LU."""

def lu_factorization(A):
    """
    Perform LU factorization with partial pivoting.
    Returns P, L, U such that PA = LU.
    """
    A = A.copy().astype(float)
    n = A.shape[0]

    L = np.zeros((n, n))
    U = A.copy()
    P = np.eye(n)

    for k in range(n):
        # Partial pivoting: find index of max element in column k from row k downward
        pivot = np.argmax(np.abs(U[k:, k])) + k

        if np.isclose(U[pivot, k], 0.0):
            raise ValueError("Matrix is singular!")

        # Swap rows in U
        if pivot != k:
            U[[k, pivot], :] = U[[pivot, k], :]
            P[[k, pivot], :] = P[[pivot, k], :]
            # Swap rows in L (only the first k columns)
            if k > 0:
                L[[k, pivot], :k] = L[[pivot, k], :k]

        # Elimination
        for i in range(k + 1, n):
            L[i, k] = U[i, k] / U[k, k]
            U[i, k:] = U[i, k:] - L[i, k] * U[k, k:]

    # Set diagonal of L to 1
    for i in range(n):
        L[i, i] = 1.0

    return P, L, U

"""defining a function 'forward_substitution(L, b)' that Solve Ly = b for y, where L is unit lower triangular."""

def forward_substitution(L, b):
    """
    Solve Ly = b for y, where L is lower triangular with 1s on diagonal.
    """
    n = L.shape[0]
    y = np.zeros_like(b, dtype=float)

    for i in range(n):
        y[i] = b[i] - np.dot(L[i, :i], y[:i])

    return y

"""defining a function 'backward_substitution(U, y)' that Solve Ux = y for x, where U is upper triangular."""

def backward_substitution(U, y):
    """
    Solve Ux = y for x, where U is upper triangular.
    """
    n = U.shape[0]
    x = np.zeros_like(y, dtype=float)

    for i in range(n - 1, -1, -1):
        if np.isclose(U[i, i], 0.0):
            raise ValueError("Zero pivot encountered in backward substitution!")
        x[i] = (y[i] - np.dot(U[i, i + 1:], x[i + 1:])) / U[i, i]

    return x

"""defining a solver function 'lu_solve(P,L,U,b)' , that solve Ax=b given PA=LU"""

def lu_solve(P, L, U, b):
    """
    Solve Ax = b given PA = LU.
    """
    Pb = P @ b
    y = forward_substitution(L, Pb)
    x = backward_substitution(U, y)
    return x

"""defining function 'backward_error(A, P, L, U)' to calculate backward error of factorization, ie.  ||PA âˆ’ LU||/||A||"""

def backward_error(A, P, L, U):
    """
    Compute ||PA - LU|| / ||A||
    """
    num = np.linalg.norm(P @ A - L @ U)
    den = np.linalg.norm(A)
    return num / den

"""defining function 'residual(A, x, b)' to calculate backward error of factorization, ie.  ||Ax - b|| / ||b||"""

def residual(A, x, b):
    """
    Compute ||Ax - b|| / ||b||
    """
    num = np.linalg.norm(A @ x - b)
    den = np.linalg.norm(b)
    return num / den